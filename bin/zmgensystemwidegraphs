#!/usr/bin/perl
# 
# ***** BEGIN LICENSE BLOCK *****
# Version: ZPL 1.1
# 
# The contents of this file are subject to the Zimbra Public License
# Version 1.1 ("License"); you may not use this file except in
# compliance with the License. You may obtain a copy of the License at
# http://www.zimbra.com/license
# 
# Software distributed under the License is distributed on an "AS IS"
# basis, WITHOUT WARRANTY OF ANY KIND, either express or implied. See
# the License for the specific language governing rights and limitations
# under the License.
# 
# The Original Code is: Zimbra Collaboration Suite.
# 
# The Initial Developer of the Original Code is Zimbra, Inc.
# Portions created by Zimbra are Copyright (C) 2005 Zimbra, Inc.
# All Rights Reserved.
# 
# Contributor(s):
# 
# ***** END LICENSE BLOCK *****
# 

use strict;
use lib '/opt/zimbra/zimbramon/lib';
use lib '/opt/zimbra/zimbramon/lib/Zimbra/Mon';

my $DEBUG=0;

use Time::Local;
use Logger;

my $baseDir = "/opt/zimbra";
my $logDir = "$baseDir/log";

my $pstring;
my $beg;
my $step;
my $count;

my %hosts = ();
my %values = ();

my @DATANAMES=(
	"LmtpRcvdData:total:bytes",
	"LmtpRcvdMsgs:total:count",
	"Slice:/opt/zimbra",
	"Slice:/opt/zimbra/db",
	"Slice:/opt/zimbra/index",
	"Slice:/opt/zimbra/log",
	"Slice:/opt/zimbra/redolog",
	"Slice:/opt/zimbra/store"
	);

sub datetime_to_timestamp {
	my $dt = shift;
	if ($dt eq "" || !defined ($dt)) {
		return "0000000000";
	}
	if ($dt =~ m/^\d\d\d\d-\d\d-\d\d$/) {
		$dt .= " 00:00:00";
	}

	my ($year,$mon,$mday,$hour,$min,$sec) = 
		($dt =~ m/(\d+)-(\d+)-(\d+) (\d+):(\d+):(\d+)/);
	$mon--;
	my $ts = timelocal($sec,$min,$hour,$mday,$mon,$year);
	return $ts;
}

sub timestamp_to_datetime {
	my $ts = shift;
	if ($ts eq "" || !defined($ts)) {
		return '1000-01-01 00:00:00';
	}
	my @s= localtime($ts);

 	#'YYYY-MM-DD HH:MM:SS'
	my $dt = sprintf ("%4d-%02d-%02d %02d:%02d:%02d",$s[5]+1900,$s[4]+1,$s[3],$s[2],$s[1],$s[0]);
	return $dt;
}

sub fetch_saved_values {
	my $fname = shift;
	my $name = shift;

	open FILE, $fname or die "Can't open $fname: $!";
	my @lines = <FILE>;
	close FILE;
	
	foreach my $l (@lines) {
		chomp $l;
		my ($h,$t,$v) = split (/,/, $l);
		$hosts{$h} = $h;

		if ($name !~ /^Slice/) {
			$values{$t} += $v;
		} else {
			#2:1814:174425:/dev/sda3:185671
			my @vs=split (/:/,$v);
			my @os=split (/:/,$values{$t});
			$vs[0]+=$os[0];
			$vs[1]+=$os[1];
			$vs[2]+=$os[2];
			$vs[4]+=$os[4];
			$values{$t} = "$vs[0]:$vs[1]:$vs[2]:various:$vs[4]";
		}
	}

}


my $date = timestamp_to_datetime(time());

# Arguments are stat name, period and optional date
foreach my $sn (@DATANAMES) {
	foreach my $period (@ARGV) {

		if ($period eq "d") {
			$pstring = 1;
			$step = 3600;
			$count = 24;
		} elsif ($period eq "3m") {
			$pstring = 24;
			$step = 86400;
			$count = 90;
		} elsif ($period eq "12m") {
			$pstring = 24;
			$step = 86400;
			$count = 365;
		} else {
			print STDERR "Invalid period\n\n";
			next;
		}

		my $xlabel;

		my $startdate = datetime_to_timestamp($date);

		if ($period eq "d") {
			$startdate -= (60*60*24);
			$xlabel = '-x MINUTE:30:HOUR:1:HOUR:4:0:%H --no-minor';
		} elsif ($period eq "3m") {
			$startdate -= (60*60*24*30*3);
			$xlabel = '-x WEEK:1:WEEK:2:WEEK:2:604800:%d/%b';
		} elsif ($period eq "12m") {
			$startdate -= (60*60*24*365);
			$xlabel = '-x DAY:15:MONTH:1:MONTH:2:2592000:%b --no-minor';
		}

		$startdate = timestamp_to_datetime($startdate);

		$beg = '-5y';

		($DEBUG) && print STDERR "SN: $sn\nP: $startdate\nE: $date\n";
        print STDERR "Generate systemwide graphs for $sn from $startdate to $date ($period)\n";

		my $name = $sn;
		my $keyname;
		my $massage_disk_slice_data = 0;
		my $unit = "";
		my $upper = "";
		my $lower = "";
		my $max = 0;

		if ($name =~ m/^Slice/) {
			$massage_disk_slice_data = 1;
			$unit = "--unit MB -v MB";
			$lower = "-l 0";
			$name =~ s|.*/||g;
			$keyname = "/opt/zimbra/$name";
			if ($keyname eq "/opt/zimbra/zimbra") {
				$keyname = "/opt/zimbra";
			}
		} else {
			$name =~ s/:.*//g;
			$keyname = $name;
		}


		my $uname = "zimbra";
		my $pass = `/opt/zimbra/bin/zmlocalconfig -s zimbra_ldap_password`;
		$pass = (split (' ',$pass))[2];
		chomp $pass;

		my $fetch = "$baseDir/bin/zmfetchallstats";

		`$fetch -S $sn -P $period -b "$startdate" -e "$date" -u $uname -p $pass >/tmp/fetch.$$`;

		fetch_saved_values ("/tmp/fetch.$$", $sn);

		unlink "/tmp/fetch.$$";

		my $base = "/opt/zimbra/zimbramon/rrdtool";
		my $work = "${base}/work";
		my $rrd = "${base}/bin/rrdtool";
		my $db = "${work}/Systemwide_${name}.${period}.rrd";
		my $graph = "${work}/Systemwide_${name}.${period}.gif";

		if (! -d $work) {mkdir ($work, 0777);}

		unlink -f $db;

		($DEBUG) && print STDERR 
		"$rrd create $db -b $beg -s $step DS:$name:GAUGE:86400:U:U RRA:AVERAGE:0.2:1:$count\n";
		`$rrd create $db -b $beg -s $step DS:$name:GAUGE:86400:U:U RRA:AVERAGE:0.2:1:$count`;

		my $sts = -1;
		my $ets = -1;

		foreach my $ts (sort keys %values) {
			# print STDERR "Found $$row[0] $$row[1]\n";
			my $val = $values{$ts};
			# my $tm = timestamp_to_datetime($ts);

			if ($massage_disk_slice_data) {
				# val:used:avail:dev:blk
				my @fields = split ':', $val;
				$val = $fields[1];
				if ( $fields[4] > $max ) {
					$max = $fields[4];
					$upper = "-u $max";
				}
				if ($sts == -1) {
					$keyname = "\'$keyname ($fields[3]) (MB)\'";
				}
			}

			if ($sts == -1) {$sts = $ts; $ets = $ts;}
			else {$ets = $ts;}

			($DEBUG) && print STDERR "$rrd update $db $ts:$val\n";
			`$rrd update $db $ts:$val`;
		}

		if ($sts eq "-1" || $ets eq "-1") {
			print STDERR "No values returned\n";
			next;
		}

		($DEBUG) && print STDERR "$rrd graph $graph --start $sts --end $ets $xlabel DEF:count=${db}:${name}:AVERAGE LINE2:count#ff0000:$keyname\n";
		`$rrd graph $graph --start $sts --end $ets $xlabel DEF:count=${db}:${name}:AVERAGE LINE2:count#ff0000:$keyname`;
	}
}
